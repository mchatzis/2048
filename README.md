# 2048 Project (My first ever software project)
This repository concerns the 2048 game programmed in C++, using the terminal as a GUI. It is a simple project I had for my first year module of Software Engineering. However, the final solution is quite elegant for my first ever programming project.
## 1. Initial Approach
My first approach was to create a function for each direction (up, down, left, right). I managed to create the program very quickly but it was long, inefficient and ugly. 
My second approach was to use only one function which would take as input the basic multidimensional vector(passed by reference) and two parameters that I would use inside the for loops in order to differentiate the counters according to the direction set by the user. This approach was far more complicated but far more efficient and clever. I managed to write the code but I didn’t manage to correct some bugs related to having a sequence like this (2 0 2 0) in a column.  
The final approach that you can see in the final program is very efficient and very similar to my second approach. I chose this one because it is both easy to implement and efficient.  

## 2. Final Program Explained Step by Step
1. The main asks for an input file and extracts all the information storing it in a 2 dimensional vector. If the user enters an invalid name or a file with all zeroes or a file with non-multiples of 2, the game starts from the default configuration. This is to avoid non-sense games.  
2. Then the program initiates a while loop whose condition is if the game is over yet. This is checked by the bool game_over function which checks if the game matrix has any moves (i.e. if there is at least one zero or if there is at least a pair of neighbouring numbers that are equal) and returns true of false accordingly. If the game is over the program prints “game over” and exits the game. If the game is not over: 
3. The program asks for user command, either w or s or a or d and their respective capitals. Depending on the command it sets the direction in which the game function should operate as shown in [this](https://drive.google.com/open?id=1RM-UKuVxZjRYZoYJxDfjwc4_OnGpDmIr) picture.
4. These are then fed to the main function of the program (bool game) as input parameters. Moreover, the main matrix 2-dimensional vector is passed by reference. The main function does the following: 
    - If the user has pressed W or S, it rotates the matrix by 90 degrees (takes the transpose) so that the functions following are the same for all 4 directions. It is like converting up – down to right – left and then back.  
    - Then the direction2 (distinguishes between down and up and between left and right) determines to which way the numbers are sorted. For instance, if direction2(in main) = d(in function game)= 1, then all the numbers are sorted to the right by the function bool push demonstrated in the following example: 
      For d = 1:      2 0 2 4          becomes --> 0 2 2 4 
	                    2 0 0 0  	 becomes -->  0 0 0 2 (after 3 loops) 
      For d = -1:     2 0 2 4  	 becomes  2 2 4 0  	 	etc. 
    - Note that the function push  is of type bool. If the numbers can be sorted then there is a move to the direction that the user wishes. Hence, the function returns true when the numbers can be sorted and false if they cannot. This condition is passed by reference to the function game. It is given as value to the variable move_exists. This value starts from false every time. If the numbers can be sorted OR if any two neighbouring numbers are the same (found in the if statement of function game line 187) then move_exists becomes true and it is returned by the function game to the main. In the main if a move exists, then it is executed and the matrix is printed, otherwise the program does nothing as requested by the requirements of the program and then it waits for another move by the user. 
    - Then the game function takes every entry and checks its neighbouring one. If they are the same they are added (the right one becomes zero) and if not nothing happens. Then the only thing remaining is to push again all numbers to the direction desired, which is done immediately after the for loops in function game.  
    - If the user has chosen the up or down direction, the matrix must be rotated again to its normal form. Again the function rotating takes the transpose (90 degrees rotation). Note that the function rotating only exchanges the diagonally reflected indices and does not affect the diagonal. This comes from the definition of the transpose of a matrix and is the most efficient way to rotate the matrix. 
    - Finally, a random ZERO INDEX of the matrix becomes TWO using the function random at the end of the function IF there exists a move. The function random needs further explaining: i) The random function adds all the indices of the matrix to a vector of type matrixentry(structure created for this reason)  then a random number is defined using the function rand() of the cstd library. Note that the range of the random number equals the size of the zeroentry vector because this is also the amount of the zero entries. The random number is huge and its modulus with the amount of zeroes in the matrix is taken. This is to ensure that there is an equal probability of obtaining a zero in each zero entry. Then the random number is used to transform randomly one zero entry to 2.  To give an example, if the loop finds 5 zero entries, then a random number from 0 to 4 is generated using the modulus. In this way, each zero entry has a 1/5 chance of being chosen to become 2. 
5. Finally, in the main the matrix is printed using the function printing. Note that the matrix is passed by constant reference since it is not needed as an output, only as an input. It also saves some memory in the RAM since it is passed by constant reference and not by value.

Final Note: The program was made in such a way so that with a few minor changes, it can be made to work for an nxn matrix!! This was one of the basic reasons I chose this approach. In fact I tested it for nxn and it worked most times with minor bugs that could be corrected with 2 or 3 if statements. 
